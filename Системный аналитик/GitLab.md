https://kolesnikof.gitbooks.io/git-basics/content/base.html

- **HEAD**
В первую очередь, поговорим о "HEAD". HEAD - это символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы в данный момент работаем.
HEAD всегда указывает на последний коммит из вашего локального дерева. Большинство команд Git, изменяющих рабочее дерево, начнут с изменения HEAD.

- **MOVING**
- Перемещение на один коммит назад `^`
- Перемещение на несколько коммитов назад `~<num>`- 
Для начала рассмотрим оператор каретки (^). Когда мы добавляем его к имени ссылки, Git воспринимает это как указание найти родителя указанного коммита.
Так что `main^` означает "первый родитель ветки `main`".
`main^^` означает прародитель (родитель родителя) `main`
Одна из наиболее распространённых целей, для которых используются относительные ссылки - это перемещение веток. Можно напрямую **==прикрепить ветку==** к коммиту при помощи опции `-f`. Например, команда:
`git branch -f main HEAD~3`

- **commit** : 
Коммит в git репозитории хранит снимок всех файлов в директории. Почти как огромная копия, только лучше

- **branch**:
Kоманда `git branch` позволяет создавать, просматривать, переименовывать и удалять ветки. Она не дает возможности переключаться между ветками или выполнять слияние разветвленной истории.
git branch -f main HEAD~3 - ==перемещение ветки== майн на 3 назад

https://www.atlassian.com/ru/git/tutorials/using-branches

- **checkout**:
Команда `git checkout` позволяет перемещаться между ветками, созданными командой `git branch`.
https://www.atlassian.com/ru/git/tutorials/using-branches/git-checkout

- **cherry-pick**
Первая из таких команд - это `git cherry-pick`. Она выглядит вот так:

- `git cherry-pick <Commit1> <Commit2> <...>`

Это очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (`HEAD`).
- **reset**:
Команда `git reset` — это сложный универсальный инструмент для отмены изменений. Она имеет три основные формы вызова, соответствующие аргументам командной строки `--soft, --mixed, --hard`. Каждый из этих трех аргументов соответствует трем внутренним механизмам управления состоянием Git: дереву коммитов (`HEAD`), разделу проиндексированных файлов и рабочему каталогу.
`git reset` отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории"; `git reset` перенесёт ветку назад, как ==будто некоторых коммитов вовсе и не было.==

- **revert**:
Команда `git revert` используется для отката изменений в истории коммитов репозитория. Другие команды отмены, такие как [git checkout](https://www.atlassian.com/ru/git/tutorials/using-branches/git-checkout) и [git reset](https://www.atlassian.com/ru/git/tutorials/undoing-changes/git-reset), перемещают указатель `HEAD` и указатели ветки на определенный коммит. Команда `git revert` также работает с определенным коммитом, однако использование `git revert` не перемещает указатели. При операции revert совершается переход к указанному коммиту, обращаются его изменения и создается новый, «обратный» коммит. Затем позиция указателей обновляется — они перемещаются к этому коммиту в конце ветки. ==Старый коммит сохраняется и создается новый с изменениями противоположными внесенным ранее.==
- **rebase**:
Из [документации](https://git-scm.com/docs/git-rebase) — это наложение коммитов поверх другого базового коммита. Под базовым понимается тот коммит, к которому применяются коммиты выбранной ветки.
Перебазирование в git используется для придания линейности истории ветки, чтобы удобно отслеживать изменения, или для обновления ветки разработки последними изменениями из основной ветки.
==Всё, что нужно для интерактивного rebase - это опция `-i`==
Если добавить эту опцию, Git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель rebase (target). Также показываются хеши коммитов и комментарии к ним, так что можно легко понять что к чему.
После открытия окна интерактивного rebase есть три варианта для каждого коммита:
- Можно сменить положение коммита по порядку, переставив строчку с ним в редакторе (у нас в окошке строку с коммитом можно перенести просто мышкой).
- Можно "выкинуть" коммит из ребейза. Для этого есть `pick` - переключение его означает, что нужно выкинуть коммит.
- Наконец, можно соединить коммиты. В этом уровне игры у нас не реализована эта возможность, но, вкратце, при помощи этой функции можно объединять изменения двух коммитов.
==пример git rebase -i HEAD~4==

- **merge**:
Команда `git merge` выполняет слияние отдельных направлений разработки, созданных с помощью команды `git branch`, в единую ветку.
https://habr.com/ru/articles/432420/

- **clone** Технически, `git clone` в реальной жизни - это команда, которая создаст _локальную_ копию удалённого репозитория
Вы, наверное, догадались, что первый символ `o/` в названии ветки служит для обозначения именно удалённых веток. Да. Удалённые ветки также имеют (обязательное) правило именования - они отображаются в формате:
`<удалённый репозиторий>/<имя ветки>`

- **fetch** как извлекать данные _из_ удалённого репозитория - и для этого у нас есть соответствующая команда `git fetch`.
`git fetch` ==выполняет две и только две основные операции==. А именно:
связывается с указанным удалённым репозиторием и забирает все те данные проекта, которых у вас ещё нет, при этом...
 у вас должны появиться ссылки на все ветки из этого удалённого репозитория (например, `o/main`)
 ==Важно== отметить, что команда `git fetch` забирает данные в ваш _локальный_ репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент.
Фактически, `git fetch` синхронизирует _локальное_ представление удалённых репозиториев с тем, что является _актуальным_ на текущий момент времени.
Следовательно, если вы взглянете на имя ветки `o/main`, то здесь `main` - это имя ветки, а `o` - это имя удалённого репозитория.

- **pull** Процедура _скачивания (fetching)_ изменений с удалённой ветки и _объединения (merging)_ настолько частая и распространённая, что git предоставляет вместо двух команд - одну! Эта команда - `git pull`.
- **push** - this command is opposite to pull Способ, которым мы воспользуемся, является противоположным тому способу, которым мы пользовались ранее для скачивания наработок (`git pull`). Этот способ - использование команды `git push`!
- rebasing `git pull --rebase` - аналог для совместно вызванных fetch и rebase!

Команда `git push` отвечает за загрузку _ваших_ изменений в указанный удалённый репозиторий, а также включение ваших коммитов в состав удалённого репозитория. По окончании работы команды `git push` все ваши друзья смогут скачать себе все сделанные вами наработки.



**Общая информация:** Ты можешь делиться результатами с друзьями при помощи `export tree` и `import tree`
Хочешь создать классный уровень? Сделай это при помощи `build level` или добавь уровень друга при помощи `import level`
Команда `show commands` покажет все доступные инструкции. Там есть очень полезные, например `undo` и `reset`
Но в отличие от количества коммитов, на которые нужно откатиться назад **(как делает `~`), номер после `^` определяет**, на какого из родителей мерджа надо перейти. Учитывая, что мерджевый коммит имеет двух родителей, просто указать `^` нельзя.
Git по умолчанию перейдёт на "первого" родителя коммита, но указание номера после `^` изменяет это поведение.

fakeTeamwork - make commit in udalennom reprezetorii
fakeTeamwork name n - name vetka on which we will make commit and n - number of commit

==Использованные команды:==
**git rebase -i HEAD~n** возможность менять/переставлять/удалять коммиты
**git commit** - добавление коммита
**git commit** --amend - добавления изменения
**git rebase name** - перенесение коммитов с одной ветки (на которой head) на ветку name
**git tag v1 C1** - Мы назвали тег `v1` и заставили его ссылаться на `C1` явным образом. Если конкретный коммит не указан, гит пометит тегом `HEAD`.
**git checkout v1** - head will be on commit witth tagv1
**git describe** выглядит примерно так:
`git describe <ref>`
Где `ref` — это что-либо, что указывает на конкретный коммит. Если не указать `ref`, то git будет считать, что указано текущее положение (`HEAD`).
*Вывод команды выглядит примерно так:*
`<tag>_<numCommits>_g<hash>`
Где `tag` – это ближайший тег в истории изменений, `numCommits` – это на сколько далеко мы от этого тега, а `hash` – это хеш коммита, который описывается. Example Команда `git describe main` выведет:
`v1_2_gC2`
**git rebase main bugFix** -коммит багфикс пеереносится сразу после крайнего комита мейн
Если коммиты находятся на одной ветке то команда git rebase перемещает ветки?
**git checkout main^2** - перемещает нас на второго родителя (работает только если ветки сливались)
**git checkout HEAD~^2~2**- можно использовать вместе, перемещает на одну назад на не основного родителя и на два назад
**git branch bugWork main^^2^** - можно сразу переместиться и создать ветку
**git checkout -b name** - создает новую ветку и переключается на нее 